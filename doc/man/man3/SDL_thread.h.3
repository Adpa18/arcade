.TH "/home/wery_a/rendu/CPP/cpp_arcade/library/sdl2/include/SDL_thread.h" 3 "Mercredi 30 Mars 2016" "Version 1" "Arcade" \" -*- nroff -*-
.ad l
.nh
.SH NAME
/home/wery_a/rendu/CPP/cpp_arcade/library/sdl2/include/SDL_thread.h \- 
.SH SYNOPSIS
.br
.PP
\fC#include 'SDL_stdinc\&.h'\fP
.br
\fC#include 'SDL_error\&.h'\fP
.br
\fC#include 'SDL_atomic\&.h'\fP
.br
\fC#include 'SDL_mutex\&.h'\fP
.br
\fC#include 'begin_code\&.h'\fP
.br
\fC#include 'close_code\&.h'\fP
.br

.SS "Définitions de type"

.in +1c
.ti -1c
.RI "typedef struct \fBSDL_Thread\fP \fBSDL_Thread\fP"
.br
.ti -1c
.RI "typedef unsigned long \fBSDL_threadID\fP"
.br
.ti -1c
.RI "typedef unsigned \fBint\fP \fBSDL_TLSID\fP"
.br
.in -1c
.SS "Énumérations"

.in +1c
.ti -1c
.RI "enum \fBSDL_ThreadPriority\fP { \fBSDL_THREAD_PRIORITY_LOW\fP, \fBSDL_THREAD_PRIORITY_NORMAL\fP, \fBSDL_THREAD_PRIORITY_HIGH\fP }"
.br
.in -1c
.SS "Fonctions"

.in +1c
.ti -1c
.RI "typedef \fBint\fP (\fBSDLCALL\fP *SDL_ThreadFunction)(\fBvoid\fP *\fBdata\fP)"
.br
.ti -1c
.RI "\fBDECLSPEC\fP \fBSDL_Thread\fP *\fBSDLCALL\fP \fBSDL_CreateThread\fP (SDL_ThreadFunction fn, \fBconst\fP char *\fBname\fP, \fBvoid\fP *\fBdata\fP)"
.br
.ti -1c
.RI "\fBDECLSPEC\fP \fBconst\fP char *\fBSDLCALL\fP \fBSDL_GetThreadName\fP (\fBSDL_Thread\fP *thread)"
.br
.ti -1c
.RI "\fBDECLSPEC\fP \fBSDL_threadID\fP \fBSDLCALL\fP \fBSDL_ThreadID\fP (\fBvoid\fP)"
.br
.ti -1c
.RI "\fBDECLSPEC\fP \fBSDL_threadID\fP \fBSDLCALL\fP \fBSDL_GetThreadID\fP (\fBSDL_Thread\fP *thread)"
.br
.ti -1c
.RI "\fBDECLSPEC\fP \fBint\fP \fBSDLCALL\fP \fBSDL_SetThreadPriority\fP (\fBSDL_ThreadPriority\fP priority)"
.br
.ti -1c
.RI "\fBDECLSPEC\fP \fBvoid\fP \fBSDLCALL\fP \fBSDL_WaitThread\fP (\fBSDL_Thread\fP *thread, \fBint\fP *status)"
.br
.ti -1c
.RI "\fBDECLSPEC\fP \fBvoid\fP \fBSDLCALL\fP \fBSDL_DetachThread\fP (\fBSDL_Thread\fP *thread)"
.br
.ti -1c
.RI "\fBDECLSPEC\fP \fBSDL_TLSID\fP \fBSDLCALL\fP \fBSDL_TLSCreate\fP (\fBvoid\fP)"
.br
.RI "\fICreate an identifier that is globally visible to all threads but refers to data that is thread-specific\&. \fP"
.ti -1c
.RI "\fBDECLSPEC\fP \fBvoid\fP *\fBSDLCALL\fP \fBSDL_TLSGet\fP (\fBSDL_TLSID\fP \fBid\fP)"
.br
.RI "\fIGet the value associated with a thread local storage ID for the current thread\&. \fP"
.ti -1c
.RI "\fBDECLSPEC\fP \fBint\fP \fBSDLCALL\fP \fBSDL_TLSSet\fP (\fBSDL_TLSID\fP \fBid\fP, \fBconst\fP \fBvoid\fP *\fBvalue\fP, \fBvoid\fP(*destructor)(\fBvoid\fP *))"
.br
.RI "\fISet the value associated with a thread local storage ID for the current thread\&. \fP"
.in -1c
.SH "Description détaillée"
.PP 
Header for the SDL thread management routines\&. 
.PP
Définition dans le fichier \fBSDL_thread\&.h\fP\&.
.SH "Documentation des définitions de type"
.PP 
.SS "typedef struct \fBSDL_Thread\fP \fBSDL_Thread\fP"

.PP
Définition à la ligne 46 du fichier SDL_thread\&.h\&.
.SS "typedef unsigned long \fBSDL_threadID\fP"

.PP
Définition à la ligne 49 du fichier SDL_thread\&.h\&.
.SS "typedef unsigned \fBint\fP \fBSDL_TLSID\fP"

.PP
Définition à la ligne 52 du fichier SDL_thread\&.h\&.
.SH "Documentation du type de l'énumération"
.PP 
.SS "enum \fBSDL_ThreadPriority\fP"
The SDL thread priority\&.
.PP
\fBNote:\fP
.RS 4
On many systems you require special privileges to set high priority\&. 
.RE
.PP

.PP
\fBValeurs énumérées\fP
.in +1c
.TP
\fB\fISDL_THREAD_PRIORITY_LOW \fP\fP
.TP
\fB\fISDL_THREAD_PRIORITY_NORMAL \fP\fP
.TP
\fB\fISDL_THREAD_PRIORITY_HIGH \fP\fP
.PP
Définition à la ligne 59 du fichier SDL_thread\&.h\&.
.SH "Documentation des fonctions"
.PP 
.SS "typedef int (\fBSDLCALL\fP * SDL_ThreadFunction)"
The function passed to \fBSDL_CreateThread()\fP\&. It is passed a void* user context parameter and returns an int\&. 
.SS "\fBDECLSPEC\fP \fBSDL_Thread\fP* \fBSDLCALL\fP SDL_CreateThread (SDL_ThreadFunction fn, \fBconst\fP char * name, \fBvoid\fP * data)"
Create a thread\&.
.PP
Thread naming is a little complicated: Most systems have very small limits for the string length (Haiku has 32 bytes, Linux currently has 16, Visual C++ 6\&.0 has nine!), and possibly other arbitrary rules\&. You'll have to see what happens with your system's debugger\&. The name should be UTF-8 (but using the naming limits of C identifiers is a better bet)\&. There are no requirements for thread naming conventions, so long as the string is null-terminated UTF-8, but these guidelines are helpful in choosing a name:
.PP
http://stackoverflow.com/questions/149932/naming-conventions-for-threads
.PP
If a system imposes requirements, SDL will try to munge the string for it (truncate, etc), but the original string contents will be available from \fBSDL_GetThreadName()\fP\&. 
.SS "\fBDECLSPEC\fP \fBvoid\fP \fBSDLCALL\fP SDL_DetachThread (\fBSDL_Thread\fP * thread)"
A thread may be 'detached' to signify that it should not remain until another thread has called \fBSDL_WaitThread()\fP on it\&. Detaching a thread is useful for long-running threads that nothing needs to synchronize with or further manage\&. When a detached thread is done, it simply goes away\&.
.PP
There is no way to recover the return code of a detached thread\&. If you need this, don't detach the thread and instead use \fBSDL_WaitThread()\fP\&.
.PP
Once a thread is detached, you should usually assume the SDL_Thread isn't safe to reference again, as it will become invalid immediately upon the detached thread's exit, instead of remaining until someone has called \fBSDL_WaitThread()\fP to finally clean it up\&. As such, don't detach the same thread more than once\&.
.PP
If a thread has already exited when passed to \fBSDL_DetachThread()\fP, it will stop waiting for a call to \fBSDL_WaitThread()\fP and clean up immediately\&. It is not safe to detach a thread that might be used with \fBSDL_WaitThread()\fP\&.
.PP
You may not call \fBSDL_WaitThread()\fP on a thread that has been detached\&. Use either that function or this one, but not both, or behavior is undefined\&.
.PP
It is safe to pass NULL to this function; it is a no-op\&. 
.SS "\fBDECLSPEC\fP \fBSDL_threadID\fP \fBSDLCALL\fP SDL_GetThreadID (\fBSDL_Thread\fP * thread)"
Get the thread identifier for the specified thread\&.
.PP
Equivalent to \fBSDL_ThreadID()\fP if the specified thread is NULL\&. 
.SS "\fBDECLSPEC\fP \fBconst\fP char* \fBSDLCALL\fP SDL_GetThreadName (\fBSDL_Thread\fP * thread)"
Get the thread name, as it was specified in \fBSDL_CreateThread()\fP\&. This function returns a pointer to a UTF-8 string that names the specified thread, or NULL if it doesn't have a name\&. This is internal memory, not to be free()'d by the caller, and remains valid until the specified thread is cleaned up by \fBSDL_WaitThread()\fP\&. 
.SS "\fBDECLSPEC\fP \fBint\fP \fBSDLCALL\fP SDL_SetThreadPriority (\fBSDL_ThreadPriority\fP priority)"
Set the priority for the current thread 
.SS "\fBDECLSPEC\fP \fBSDL_threadID\fP \fBSDLCALL\fP SDL_ThreadID (\fBvoid\fP)"
Get the thread identifier for the current thread\&. 
.SS "\fBDECLSPEC\fP \fBSDL_TLSID\fP \fBSDLCALL\fP SDL_TLSCreate (\fBvoid\fP)"

.PP
Create an identifier that is globally visible to all threads but refers to data that is thread-specific\&. 
.PP
\fBRenvoie:\fP
.RS 4
The newly created thread local storage identifier, or 0 on error
.RE
.PP
.PP
.nf
1 static SDL_SpinLock tls_lock;
2 static SDL_TLSID thread_local_storage;
3 
4 void SetMyThreadData(void *value)
5 {
6     if (!thread_local_storage) {
7         SDL_AtomicLock(&tls_lock);
8         if (!thread_local_storage) {
9             thread_local_storage = SDL_TLSCreate();
10         }
11         SDL_AtomicUnlock(&tls_lock);
12     }
13     SDL_TLSSet(thread_local_storage, value, 0);
14 }
15 
16 void *GetMyThreadData(void)
17 {
18     return SDL_TLSGet(thread_local_storage);
19 }
.fi
.PP
.PP
\fBVoir également:\fP
.RS 4
\fBSDL_TLSGet()\fP 
.PP
\fBSDL_TLSSet()\fP 
.RE
.PP

.SS "\fBDECLSPEC\fP \fBvoid\fP* \fBSDLCALL\fP SDL_TLSGet (\fBSDL_TLSID\fP id)"

.PP
Get the value associated with a thread local storage ID for the current thread\&. 
.PP
\fBParamètres:\fP
.RS 4
\fIid\fP The thread local storage ID
.RE
.PP
\fBRenvoie:\fP
.RS 4
The value associated with the ID for the current thread, or NULL if no value has been set\&.
.RE
.PP
\fBVoir également:\fP
.RS 4
\fBSDL_TLSCreate()\fP 
.PP
\fBSDL_TLSSet()\fP 
.RE
.PP

.SS "\fBDECLSPEC\fP \fBint\fP \fBSDLCALL\fP SDL_TLSSet (\fBSDL_TLSID\fP id, \fBconst\fP \fBvoid\fP * value, \fBvoid\fP(*)(\fBvoid\fP *) destructor)"

.PP
Set the value associated with a thread local storage ID for the current thread\&. 
.PP
\fBParamètres:\fP
.RS 4
\fIid\fP The thread local storage ID 
.br
\fIvalue\fP The value to associate with the ID for the current thread 
.br
\fIdestructor\fP A function called when the thread exits, to free the value\&.
.RE
.PP
\fBRenvoie:\fP
.RS 4
0 on success, -1 on error
.RE
.PP
\fBVoir également:\fP
.RS 4
\fBSDL_TLSCreate()\fP 
.PP
\fBSDL_TLSGet()\fP 
.RE
.PP

.SS "\fBDECLSPEC\fP \fBvoid\fP \fBSDLCALL\fP SDL_WaitThread (\fBSDL_Thread\fP * thread, \fBint\fP * status)"
Wait for a thread to finish\&. Threads that haven't been detached will remain (as a 'zombie') until this function cleans them up\&. Not doing so is a resource leak\&.
.PP
Once a thread has been cleaned up through this function, the SDL_Thread that references it becomes invalid and should not be referenced again\&. As such, only one thread may call \fBSDL_WaitThread()\fP on another\&.
.PP
The return code for the thread function is placed in the area pointed to by \fCstatus\fP, if \fCstatus\fP is not NULL\&.
.PP
You may not wait on a thread that has been used in a call to \fBSDL_DetachThread()\fP\&. Use either that function or this one, but not both, or behavior is undefined\&.
.PP
It is safe to pass NULL to this function; it is a no-op\&. 
.SH "Auteur"
.PP 
Généré automatiquement par Doxygen pour Arcade à partir du code source\&.
